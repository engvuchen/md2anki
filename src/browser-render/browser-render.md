# 12-浏览器渲染原理

## 浏览器引擎（2 部分）

## 浏览器内核（渲染【页面】进程）包含的 **5** 个线程

### **（1）GUI （图形界面）渲染线程**

#### 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。

#### 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行；

#### 注意，GUI 渲染线程与 JS 引擎线程**互斥**，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结），GUI 更新会被保存在一个队列中，等到 JS 引擎空闲时立即被执行；

### **（2）JS 引擎线程**

#### 也称为 JS 内核，负责解析、运行 Javascript 脚本。（例如 V8 引擎）

#### **单线程**。一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行；

##### 历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好；

##### 多线程复杂性高；多线程操作需要加锁，编码的复杂性会增高。

###### 如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。

#### **与 GUI 渲染线程互斥**；若 JS 执行的时间过长，会导致页面渲染受阻。

##### JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程和 UI 线程同时运行)，那么渲染线程前后获得的元素就可能不一致了。

##### 为了防止渲染出现不可预期的结果，浏览器设定 GUI 渲染线程 和 JS 引擎线程为互斥关系。当 JS 引擎线程执行时，GUI 渲染线程会被挂起，GUI 更新则会被保存在一个队列中，等待 JS 引擎线程空闲时立即被执行。

### **（3）定时触发器线程**

#### setInterval 与 setTimeout 所在线程；

#### 浏览器定时计数器并不是由 JavaScript 引擎计数的。JavaScript 引擎是单线程的，若处于阻塞线程状态就会影响记计时的准确；

> 若 JS 线程堵塞，会阻塞定时器回调函数的执行

#### 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）；

#### 注意，W3C 在 HTML 标准中规定，规定**要求 setTimeout 中低于 4ms 的时间间隔算为 4ms**。

### **（4）事件触发线程：**可以和 EventLoop 结合说明

#### **归属于浏览器而不是 JS 引擎，用来控制事件循环**（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）；

#### 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中；

#### 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理；

#### 注意，由于 JS 是单线程的；这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

### **（5）网络请求（异步 HTTP）线程**

#### 在 XMLHttpRequest 连接后，通过浏览器新开一个线程请求；

#### 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调放入事件队列中。由 JavaScript 引擎执行。

## 页面渲染流程（6）

### （1）**生成 DOM 树**：浏览器接收 HTML 文件并将其解析为 **DOM** **树**

#### 过程：**服务端返回的字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM**

#### 性能优化：**少嵌套无意义的标签，标签层级尽可能保持扁平**

### （2）**生成 CSSOM 树**：浏览器接受 CSS 文件，将其转为 **CSS 树（\*\***CSSSOM\***\*）**

#### **字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSOM**

#### 浏览器需要确定下每一个节点的**样式**，这一过程**很消耗资源**。因为样式你可以自行设置给某个节点，也可以通过继承获得；浏览器需要递归 CSSOM 树，确定具体的元素的样式。

#### 性能优化：**CSS 选择器尽可能减少嵌套**；

### （3）**生成渲染树**：将第一步、第二步的树，结合为**渲染树(\*\***Render Tree\***\*)**

#### 图例-DOM+CSSOM 结合为渲染树

![](https://api2.mubu.com/v3/document_image/8b803e96-9b37-4d37-af6d-0d4d3dccfff4-371922.jpg)

### （4）**布局（回流）（\*\***Layout\***\*）**：根据渲染树来进行**布局**

### （5）**绘制（\*\***Paint\***\*）**：用 GPU 绘制

#### 重流 （reflow - 对应 layout ）

##### 样式变化影响**元素位置（** **reflow\*\***）：窗口大小改变**、**字体大小改变**、以及**元素位置改变\*\*，都会引起周围的元素改变他们以前的位置；

##### **性能消耗大**。当 Render Tree 中部分或全部元素的尺寸、结构让元素位置发生改变时，浏览器会重新渲染部分或全部文档；

#### 重绘（repaint - 对应 paint）

##### 样式变化**不影响元素位置（\*\***repaint\***\*）：**color、background-color、visibility 等，浏览器会将新样式赋予给元素并重新绘制它；

#### 参考资料：

### （6）**合成（\*\***Composition\***\*）图层**，显示在屏幕上；

### 参考资料-非 Anki

## DOM 操作性能瓶颈 &amp; 解决方案

### 性能瓶颈

#### （1）JS 需要等待 DOM 操作的结果：DOM 操作是**跨线程**的操作（因为 JS 引擎线程、渲染引擎线程，这两个线程的执行是**互斥**的）；

#### （2）DOM 操作可能引起 页面 重流、重绘；

### 解决方法** - ❗【面试题】插入几万个 DOM，如何实现页面不卡顿？**

#### **分批次部分渲染 DOM**：使用 requestAnimationFrame 渲染插入 DOM；

##### 经过实践，发现 setTimeout 也能起到类似的作用；

##### 通过 chrome 的性能工具，不能找出来两者的具体差异；

> 因为渲染是异步的，DomContentPatin / FirstContentfulPaint / OnLoaded 都挺快的；

#### **虚拟滚动**：只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动时，实时去替换渲染的内容。

#### 参考：

## CSS【link/style】 &amp; JS【script】 对 DOM 解析的影响

> DOM 解析 -&gt; 生成 DOM 树；DOM 树 + CSSOM = 渲染树

### CSS 不阻塞 DOM 解析，但 **外链【link 标签】/ 嵌入【style 标签】** CSS 会间接**阻塞 页面渲染**；

#### 不阻塞 DOM 解析： CSSOM 的构建不依赖 DOM；

#### 可能阻塞页面渲染 - 延迟 First Paint 完成时间；

##### script 执行需要获取到最新的 DOM、CSS 信息：浏览器不知道脚本的内容，碰到脚本时，只好先渲染页面；

#### **❗ 性能优化方案**

##### （1）使用内联式的 CSS。例 &lt;div style='font-size: 12px;'&gt;&lt;/div&gt;

##### （2）CSS 媒体查询 - 减少部分 CSS 资源加载

####### &lt;link href="style.css" rel="stylesheet"&gt;

> 未提供任何媒体类型或查询，它适用于所有情况，也就是说，它始终会阻塞渲染；

####### &lt;link href="print.css" rel="stylesheet" media="print"&gt;

> media = 'print', 只在打印内容时适用 --- 在网页首次加载时，该样式表不会阻塞渲染

####### &lt;link href="other.css" rel="stylesheet" media="(min-width: 40em)"&gt;

> 提供由浏览器执行的“媒体查询”: 符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。

### JS 既**阻塞 DOM 解析、也阻塞 页面渲染**

#### **阻塞 DOM 解析**

##### 浏览器不知道脚本内容，若先行解析下面的 DOM，万一脚本内全删了后面的 DOM，浏览器就白干活（例：document.write）。干脆全部停住，等脚本执行完再干活就好了；

#### **阻塞 页面渲染**：DOM 解析受阻，必然影响渲染树的生成；

#### **❗ 浏览器遇到 script 标签时，会触发页面渲染**

##### 若前面的 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕后，再执行脚本；

##### 浏览器不知道脚本的内容，碰到脚本时，只好先渲染页面，确保脚本能获取到最新的 DOM 元素信息、CSS 信息，尽管脚本可能不需要这些信息。

#### ❗ 性能优化方案

##### （1）将 script 标签放在 body 标签底部：**尽快**渲染出**完整**页面；

###### 如果在页面其他部分放置 script 标签，浏览器会立即构建该标签前的 DOM、CSSOM，显示不完整的页面；这个不完整的页面，没有什么意义；

##### （2）给 script 标签添加 defer 或者 async 属性；

###### async：解析 / 渲染后续文档元素，将和 script 的加载/执行，**并行进行**。

> 元素解析/渲染: 并行解析 / 执行 JS

###### defer：解析 / 渲染后续文档元素，将和 script 加载**并行**进行，但 script 执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成；

> 解析和元素解析/渲染并行，但执行 JS 是延迟的;

####### DOMContentLoaded + 外部资源 = loaded

####### DOMContentLoaded — 浏览器仅加载了 HTML，DOM 树已构建；但外部资源（例：图片/样式表）可能并没有下载完毕；

######## 进行 DOM 操作的最早恰当时机：可以给该事件添加回调函数；

######## 页面加载时间的判断指标；

####### loaded —— 浏览器已加载了所有的资源（图像，样式表等）。

###### 在现实中，延迟脚本（defer）并不一定会按照**顺序执行**，也不一定会在 DOMContentLoaded 事件**触发前执行**， 因此最好只包含一个 defer 脚本；

### 结论

#### CSS（**外链**或**内联**）会间接阻塞后续页面渲染（Rendering），然而 DOM 解析（Parsing）会正常进行；

#### 很多浏览器中，**CSS 会延迟脚本执行和 \*\***DOMContentLoaded\***\* 事件**；

##### **延迟脚本执行**

###### 多数脚本被编写时，就希望在样式载入之后再开始执行；

###### 开发者往往会假设 CSS 已经生效，特别是在进行一些显示相关的操作时， 比如需要得到 DOM 元素的位置和大小；

###### 若脚本位于样式之后，浏览器通常会认为该脚本依赖样式的渲染结果， 更倾向于延迟脚本的执行直到样式渲染结束，只是延迟脚本的执行，但不影响 dom 的解析。

##### **延迟 \*\***DOMContentLoaded\*\*：多数浏览器 DOMContentLoaded 事件的触发会考虑到外部样式文件（CSS）的载入，以及在 HTML 中 脚本标签和样式标签的相对位置。

#### JS 前的 DOM 可以正常解析（Parsing）和渲染（Rendering）- 前半部分，可以单独合成为 渲染树；

### ❗️ 面试题：

#### **？为什么 CSS 放在 \*\***head\***\* 标签内比较好**

##### 把样式放在 body 内容之前，以防呈现内容发生**样式跳动**（闪烁）**；**

##### 注重性能的站点都会使用**行内【标签内的 style】，提前 FP；**

#### **？为什么头部同时有 \*\***&lt;script&gt;\***\* 与 \*\***&lt;link&gt;\***\* 的情况下，最好将 \*\***&lt;script&gt; \***\*放在 \*\***&lt;link&gt;\***\* 上面**

##### 浏览器在遇到 script 标签时，根据这个 script 标签前的 DOM、CSS，先渲染出页面

###### 浏览器不知道 script 标签内的内容；但 JS 可以操作 DOM、样式；

###### 出于性能考虑，**浏览器根据这个 script 标签前的 DOM、CSS，先渲染出页面**；

###### 以便让脚本可以访问到 DOM、样式 信息；

##### 渲染树的生成，依赖 DOM、CSSOM 的构建;

#### **？说说页面性能指标**

##### 谷歌控制台测量的工具：Performance / Performance insights / Lighthouse

##### DCP（DOM Content Loaded）：整个页面的 DOM 渲染出来；

> 该事件完成后，一般能看到整体的页面结构

###### 和 onloaded，图片等资源未加载完毕

##### FCP（First Paint / First Contentful Paint）：从导航到浏览器将第一个像素渲染到屏幕的时间；

> 渲染树合成图层后，显示到屏幕。

###### 若 script 位置不对，例如在 head 中；浏览器会用不完整的 DOM、CSSOM，立即渲染页面；虽然被提前了，但这个首屏的体验不好；

###### 和 First Paint 容易混淆，在 Performance 工具里，一个页面初始化往往没有 FP，但如果再次测量，重新加载页面，因为一开始老页面还在，就会有一个 FP；

##### TTL（Time to Interactive）：首次抵达页面可交互时间

###### 页面已加载最重要的内容（例如，在第一个内容绘制或(LCP) 中定义）；

###### 页面中最明显的元素变为交互式（可点击或激活）；

###### 页面在 50 毫秒的延迟内响应用户交互。

##### LCP（Largest Contentful Paint）：最大的文本、图片被渲染完成的时间；

### 性能优化指标：

## 一帧的生命周期 - 相当于一次完整的 EventLoop

## 【面试题】关键渲染路径优化：不考虑缓存和优化网络协议的前提（外部条件）下，可以通过哪些方式来最快的渲染页面？

### 指最大限度缩短《页面渲染流程》第 1 步至第 5 步耗费的总时间：尽快将内容渲染到屏幕上，缩短首次渲染的时间。

### 一个最佳实践：**引入 CSS 在 head 标签内，普通标签在中部 body 标签，JS 标签在文档底部**；

#### CSS 在 Head 标签内：浏览器会等待此处的 link / style 解析完成，才最终显示页面；

#### CSS 若不在 Head 标签内：

##### CSSOM 在 16.7ms 内能完成：则页面显示完整，不会闪烁；

##### 不能在 16.7ms 内完成：后续的 CSSOM 完成后，浏览器再次渲染页面，当样式影响元素大小、位置，视觉上有突兀，造成“样式闪烁”；

### DOM

#### （1）扁平化 DOM；

#### （2）避免频繁地操作 DOM；

### CSS

#### （3）减少 CSS 选择器的嵌套层级；

#### （4）减少重流、重绘 - 涉及标签、样式等；

##### 💡1. CSS 选择符**从右往左**匹配查找，避免选择符层级过多；

##### 💡2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了位置）；

##### 💡3. 控制 CSS 动画速度，**动画速度越快，回流次数越多**，也可以使用 requestAnimationFrame；

##### 💡4. 将频繁重绘或者回流的节点设置为**图层**。图层能够阻止该节点的渲染行为影响别的节点；

##### 5. 使用 transform 替代 top；

##### 6. 不要使用 table 布局，因为可能很小的一个小改动会造成整个 table 的重新布局；

##### 7. 不要把节点的属性值放在一个循环里，当成循环里的变量；

## 衡量页面渲染时间是否被加快
