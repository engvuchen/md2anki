# 12-浏览器渲染原理-完成题库

## 浏览器内核（渲染【页面】进程）包含的线程（5）

### **（1）GUI （图形界面）渲染线程**

#### 作用：渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制，合成等。

#### 注意，GUI 渲染线程与 JS 引擎线程**互斥**，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结）；GUI 更新会被保存在一个队列中，等到 JS 引擎空闲时立即被执行；

### **（2）JS 引擎线程**

#### 也称为 JS 内核，负责解析、运行 Javascript 脚本。（例如 V8 引擎）

#### **单线程**。一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行；

#### **与 GUI 渲染线程互斥**；若 JS 执行的时间过长，会导致页面渲染受阻。

### **（3）定时器线程**

### **（4）事件触发线程：** 可以和 EventLoop 结合说明

### **（5）网络请求（异步 HTTP）线程**

## 页面渲染流程（6）

### （1）**生成 DOM 树**：浏览器接收 HTML 文件并将其解析为 **DOM 树**

#### 过程：字节数据（服务端返回的） =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM

#### **性能优化**：少嵌套无意义的标签，标签层级尽可能保持扁平

### （2）**生成 CSSOM 树**：浏览器接受 CSS 文件，将其转为 **CSS 树（\*\***CSSSOM\***\*）**

#### 过程：字节数据 ==&gt; 字符串 ==&gt; Token ==&gt; Node ==&gt; CSSOM；

#### 浏览器确定每一个节点的**样式**，这一过程**很消耗资源**。因为样式你可以自行设置给某个节点，也可以通过继承获得；浏览器需要递归 CSSOM 树，才能确定具体的元素的样式。

#### **性能优化**：CSS 选择器尽可能减少嵌套；

### （3）**生成渲染树**：将第一步、第二步的树，结合为**渲染树(\*\***Render Tree\***\*)**

### （4）**布局（回流）（\*\***Layout\***\*）**：根据渲染树来进行**布局**

### （5）**绘制（\*\***Paint\***\*）**：用 GPU 绘制

### （6）**合成（\*\***Composition\***\*）图层**，显示在屏幕上；

### 参考资料-非 Anki

## 重绘 / 重流的区别

### **重流** （reflow - 对应 layout ）- 元素位置变化

#### 元素位置变化，发生重流**：**窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置；

#### **性能消耗大**。当 Render Tree 中部分或全部元素的尺寸、结构让元素位置发生改变时，浏览器会重新渲染部分或全部文档；

### **重绘**（repaint - 对应 paint）- 元素位置未变化

#### 元素位置未变化**：**color、background-color、visibility 等，浏览器会将新样式赋予给元素并重新绘制它；

### 参考资料：

## DOM 操作性能瓶颈 &amp; 解决方案

### **性能瓶颈**

#### （1）DOM 操作可能引起 页面**重流**、**重绘，**使\*\* \*\*GUI 线程工作；该线程与 JS 线程互斥，工作时会让 JS 线程挂起；延长 JS 任务总执行时间；

#### （2）大批量任务会让 GUI 线程运行很久，表现为页面白屏、用户无法操作页面（I/O）；

### **解决方法 - **❗【面试题】插入几万个 DOM，如何实现页面不卡顿？

#### **（1）分批次部分渲染 DOM**：使用 requestAnimationFrame 渲染插入 DOM，

##### 经过实践，发现 setTimeout 也能起到类似的作用；

##### 通过 chrome 的性能工具，不能找出来两者的具体差异；

> 因为渲染是异步的，DomContentPatin / FirstContentfulPaint / OnLoaded 都挺快的；

#### **（2）虚拟滚动**：只渲染可视区域内的内容，非可见区域完全不渲染，当用户在滚动时，实时去替换渲染内容。

#### 参考：

## CSS【link/style】 &amp; JS【script】 对 DOM 解析的影响

> DOM 解析 -&gt; 生成 DOM 树；DOM 树 + CSSOM = 渲染树

### **1. \*\***CSS\***\* 不阻塞 DOM 解析**，但 外链【link 标签】/ 嵌入【style 标签】 CSS 会间接阻塞 页面渲染；

#### 不阻塞 DOM 解析： CSSOM 的构建不依赖 DOM；

#### 可能阻塞页面渲染 - 延迟 First Paint 完成时间；

##### script 执行需要获取到最新的 DOM、CSS 信息：浏览器不知道脚本的内容，碰到脚本时，只好先渲染页面；

#### **❗ 性能优化方案**

##### （1）使用内联式的 CSS。例 &lt;div style='font-size: 12px;'&gt;&lt;/div&gt;

##### （2）CSS 媒体查询 - 减少部分 CSS 资源加载

### 2. **JS\*\*** 阻塞 DOM 解析，间接阻塞 页面渲染\*\*

#### **（1）阻塞 DOM 解析**

##### 浏览器不知道脚本内容，若先行解析下面的 DOM，万一脚本内全删了后面的 DOM，浏览器就白干活（例：document.write）。干脆全部停住，等脚本执行完再干活就好了；

#### **（2）间接阻塞 页面渲染**：DOM 解析受阻，必然影响渲染树的生成；

#### **（3）❗ 浏览器遇到 script 标签时，会触发页面渲染**

##### 浏览器不知道脚本的内容，碰到脚本时，只好先渲染页面，确保脚本能获取到最新的 DOM、CSS 信息，尽管脚本可能不需要这些信息。

##### 若前面的 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕后，再执行脚本；

#### （4）❗ 性能优化方案

##### 1. 将 script 标签放在 body 标签底部：**尽快**渲染出**完整**页面；

###### 如果在页面其他部分放置 script 标签，浏览器会立即构建该标签前的 DOM、CSSOM，显示不完整的页面；这个不完整的页面，没有意义；

##### 2. 给 script 标签添加 defer 或者 async 属性；

###### async：解析 / 渲染后续文档元素，将和 script 的加载/执行，**并行进行**。

> 元素解析/渲染: 并行解析 / 执行 JS

###### defer：解析 / 渲染后续文档元素，将和 script 加载**并行**进行，但 script 执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成；

> 解析和元素解析/渲染并行，但执行 JS 是延迟的;

###### 在现实中，延迟脚本（defer）并不一定会按照**顺序执行**，也不一定会在 DOMContentLoaded 事件**触发前执行**， 因此最好只包含一个 defer 脚本；

### 结论

## DOMContentLoaded 和 Loaded 的区别

### **（DOMContentLoaded + 外部资源） = loaded**

### DOMContentLoaded — 浏览器仅加载了 HTML，DOM 树已构建；但外部资源（例：图片/样式表）可能并没有下载完毕；

#### 进行 DOM 操作的最早恰当时机：可以给该事件添加回调函数；

#### 页面加载时间的判断指标；

### loaded —— 浏览器已加载了所有的资源（图像，样式表等）。

## 【面试题】为什么这是一个最佳实践：CSS 在 head 标签内，普通标签在中部 body 标签，JS 标签在文档底部

### **（1）把 CSS 放在 Head 标签内，以防呈现内容发生样式跳动（闪烁）**

#### CSS 在 Head 标签内：浏览器会**等待**此处的 link / style 解析完成，才最终显示页面；

#### CSS 若不在 Head 标签内：

> 看 CSS 加载时间是否在 16.7 ms 内，超出则页面闪烁

##### CSSOM 在 16.7ms 内能完成：则页面显示完整，不会闪烁；

##### 不能在 16.7ms 内完成：后续的 CSSOM 完成后，浏览器再次渲染页面，当样式影响元素大小、位置，视觉上有突兀，造成“样式闪烁”；

### （2）注重性能的站点都会使用**行内【标签内的 style】，提前 FP**

## 【面试题】说说页面性能指标（4）

### 1. **DCP（DOM Content Loaded）**：整个页面的 DOM 渲染出来，能看到整体的页面结构

#### 外链 CSS、图片等资源未加载完毕；

### 2.** \*\***FCP（First Paint / First Contentful Paint）\*\*：从导航到浏览器将第一个像素渲染到屏幕的时间；

> 渲染树合成图层后，显示到屏幕。

### 3. **TTL（Time to Interactive）**：首次抵达页面可交互状态的时间

#### 页面已加载最重要的内容（例如，在第一个内容绘制或(LCP) 中定义）；

#### 页面中最明显的元素变为交互式（可点击或激活）；

#### 页面在 50 毫秒的延迟内响应用户交互。

### 4. **LCP（Largest Contentful Paint）**：最大的文本、图片被渲染完成的时间；

### 性能测量工具（Chrome）：Performance / Performance insights / Lighthouse

### 参考：

## 一帧的生命周期 - 相当于一次完整的 EventLoop

## 【面试题】不考虑缓存和优化网络协议的前提（外部条件）下，可通过哪些方式来加速首屏渲染？（关健渲染路径优化是？）

### 考察**关键渲染路径优化**：指最大限度缩短《页面渲染流程》第 1 ~ 5 步（DOM &gt; CSSOM &gt; RenderTree &gt; Layout &gt; Paint）耗费的总时间；尽快将内容渲染到屏幕上，缩短首次渲染的时间。

### **最佳实践**：CSS 在 head 标签内，普通标签在中部 body 标签，JS 标签在文档底部；

### **（1）DOM -** 扁平化 DOM；

### **（2）CSS - 2 方面**

#### 1. 减少 CSS 选择器的嵌套层级；

> CSS 选择符

#### 2. 减少重流、重绘 - 4

##### 1. 使用 visibility 替换 display: none ：前者只引起重绘，后者会引起回流（改变了位置）；

##### 2. 控制 CSS 动画速度：**动画速度越快，回流次数越多**，也可以使用 requestAnimationFrame；

##### 3. 将频繁重绘或者回流的节点设置为**图层**。图层能够阻止该节点的渲染行为影响别的节点；

##### 4. 不要使用 table 布局，因为可能很小的一个小改动会造成整个 table 的重新布局；

##### 6. 使用 transform 替代 top；

##### 7. 不要把节点的属性值放在一个循环里，当成循环里的变量；
